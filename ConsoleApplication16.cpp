
#include "pch.h"
#include <iostream>

#include <stdio.h>
#include <stdlib.h>
#include <locale.h>

using namespace std;

// размеры поля
#define SX 40
#define SY 20



int main()
{

	setlocale(LC_ALL, "Russian");
	//два символьных массива: предыдущие поколение и следующее
	char bef[SX][SY], aft[SX][SY];
	int x, y, z = 0;
	//заполненые пробелами - мертвыми клетками
	for (y = 0; y <= SY - 1; y++) for (x = 0; x <= SX - 1; x++) bef[x][y] = ' ';
	for (y = 0; y <= SY - 1; y++) for (x = 0; x <= SX - 1; x++) aft[x][y] = ' ';

	//первоначальное расположение живых клеток - "*"

	aft[26][4] = '*';
	aft[26][5] = '*';
	aft[26][6] = '*';
	aft[27][5] = '*';
	aft[28][5] = '*';
	aft[28][6] = '*';
	aft[28][7] = '*';

	//переменная t отвечает за количество поколений, которое вводит пользователь
	int t;
	printf("Сколько поколений будет в пройдено? : ");
	scanf_s("%d", &t);

	//ниже цикл, который отвечает за количество обновленных поколений: он проходит по массиву предыдущего поколения и проверяет "соседей" каждой  клетки согласно правилам
	for (int i = 1; i <= t; i++)
	{
		system("cls");
		//приравниаем массивы
		for (y = 1; y <= SY - 2; y++) for (x = 1; x <= SX - 2; x++) bef[x][y] = aft[x][y];

		//цикл создания нового поколения ниже
		for (y = 1; y <= SY - 2; y++)
		{
			for (x = 1; x <= SX - 2; x++)
			{
				//если встречается пустая клетка - ' ' -, то считаем ее соседей в счетчик z, и если z=3, то ставим *, иначе пропускаем 
				if (bef[x][y] == ' ')
				{
					if (bef[x - 1][y - 1] == '*') z++;
					if (bef[x][y - 1] == '*') z++;
					if (bef[x + 1][y - 1] == '*') z++;
					if (bef[x + 1][y] == '*') z++;
					if (bef[x + 1][y + 1] == '*') z++;
					if (bef[x][y + 1] == '*') z++;
					if (bef[x - 1][y + 1] == '*') z++;
					if (bef[x - 1][y] == '*') z++;
					if (z == 3) aft[x][y] = '*';
					z = 0;
				}
				else
					//если клетка = *, то проверяем количество соедей тем же счетчиком z, и если он равен 2 или 3, то клетка остается = *, иначе = ' ' 
				{
					if (bef[x - 1][y - 1] == '*') z++;
					if (bef[x][y - 1] == '*') z++;
					if (bef[x + 1][y - 1] == '*') z++;
					if (bef[x + 1][y] == '*') z++;
					if (bef[x + 1][y + 1] == '*') z++;
					if (bef[x][y + 1] == '*') z++;
					if (bef[x - 1][y + 1] == '*') z++;
					if (bef[x - 1][y] == '*') z++;
					if ((z == 2) || (z == 3))
					{
						aft[x][y] = '*';
						z = 0;
					}
					else
					{
						aft[x][y] = ' ';
						z = 0;
					}
				}
			}
		}
		//вывод нового поколения, т.е. получившегося в результате предыдущего цикла
		for (y = 1; y <= SY - 2; y++)
		{
			for (x = 1; x <= SX - 2; x++)
			{
				printf("%c", aft[x][y]);
			}
			printf("\n");
		}
		getchar();
	}
	system("pause");
	return 0;
}